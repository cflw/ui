module;
#include "头.h"
#include "用户界面.h"
#include <用户界面_布局.h>
#include "程序.h"
#include "资源.h"
export module 窗口_主窗口;
export import 用户界面.控件.下拉列表;
export import 用户界面.控件.垂直滚动条;
export import 用户界面.控件.图片;
export class W主窗口 : public 用户界面::W窗口框架 {
public:
	enum E控件编号 {
		e文字 = -1,
		e按钮0,
		e按钮1,
		e按钮2,
		e下拉列表,
		e滑动块,
		e连击按钮,
		e滚动条,
		e文本框,
		e图片,
	};
	W主窗口() = default;
	void f响应_初始化() override;
	void f事件_按键(W窗口 &, const 用户界面::S按键参数 &) override;
	void f事件_窗口值变化(W窗口 &, const int &变化前, int &变化后) override;
	用户界面::W标签 w文字{e文字};
	用户界面::W按钮 w按钮0{e按钮0};
	用户界面::W按钮 w按钮1{e按钮1};
	用户界面::W按钮 w按钮2{e按钮2};
	用户界面::W下拉列表 w下拉列表{e下拉列表};
	用户界面::W滑动块2 w滑动块{e滑动块};
	用户界面::W连击按钮 w连击按钮{e连击按钮};
	用户界面::W垂直滚动条 w滚动条{e滚动条};
	用户界面::W文本框 w文本框{e文本框};
	用户界面::W图片 w图片{e图片};
};
module : private;
//==============================================================================
// 主窗口
//==============================================================================
void W主窗口::f响应_初始化() {
	用户界面::C单向移动布局 v单向布局;
	v单向布局.f属性_s单格布局(t向量2{-100, 200}, t向量2{100, 24});
	v单向布局.f属性_s倍数移动(0, -1);
	用户界面::C网格布局 v网格布局;
	v网格布局.f属性_s中心布局(t向量2(-100, 100), t向量2(200, 200));
	v网格布局.f属性_s行列(4, 2);
	v网格布局.f生成_计算布局();
	constexpr float c按钮字号 = 18;
	//文字
	w文字.f属性_s布局({});
	w文字.f属性_s文本内容(L"aaaaaaaaaaa");
	f动作_添加窗口(w文字, true);
	//
	w按钮0.f属性_s布局(v网格布局.f计算生成(0, 0));
	w按钮0.f属性_s文本(L"按钮0", {18, 用户界面::E对齐::e居中, true, false, false, false});
	//w按钮0.f动作_获得焦点();
	f动作_添加窗口(w按钮0, true);
	//
	w按钮1.f属性_s布局(v网格布局.f计算生成(0, 1));
	w按钮1.f属性_s文本(L"按钮1", {18, 用户界面::E对齐::e居中, false, true, false, false});
	f动作_添加窗口(w按钮1, true);
	//
	w按钮2.f属性_s文本(L"窗口1", {18, 用户界面::E对齐::e居中, false, false, true, false});
	w按钮2.f属性_s布局(v网格布局.f计算生成(1, 0));
	f动作_添加窗口(w按钮2, true);
	//
	w下拉列表.f属性_s布局(v网格布局.f计算生成(1, 1));
	w下拉列表.f属性_s列表({L"123", L"321"});
	w下拉列表.m标志[W窗口::e显示背景] = false;
	w下拉列表.m标志[W窗口::e显示边框] = false;
	f动作_添加窗口(w下拉列表, true);
	//滑动块
	w滑动块.f属性_s布局({{0, -150}, {40, 40}});
	f动作_添加窗口(w滑动块, true);
	//连击按钮
	w连击按钮.f属性_s布局(v网格布局.f计算生成(2, 0));
	w连击按钮.f属性_s连击间隔(0.1f);
	f动作_添加窗口(w连击按钮, true);
	//滚动条
	w滚动条.f属性_s布局({{200, 0}, {0, 400}});
	w滚动条.f属性_s滚动值(100, 10);
	f动作_添加窗口(w滚动条, true);
	//文本框
	w文本框.f属性_s布局({{100, 100}, {200, 0}});
	f动作_添加窗口(w文本框, true);
	//图片,目前图片不能居中显示,待修复
	//w图片.f属性_s布局({{0, 0}, {125, 125}});
	//w图片.f属性_s图片源(*C图片资源::g这->fg图片(L"设置"));
	//w图片.f动作_显示();
	//f动作_添加窗口(w图片);
	//结束
	//fs按键切换(用户界面::E按键切换::e坐标);
	f动作_显示();
}
void W主窗口::f事件_按键(W窗口 &a窗口, const 用户界面::S按键参数 &a按键) {
	用户界面::C用户界面 &v用户界面 = fg引擎();
	if (&a窗口 == this) {
		w文字.f属性_s文本(L"主窗口" + std::to_wstring((int)a按键.m按键), {26});
	}
	switch (a按键.m按键) {
	case 用户界面::E按键::e确定:
		switch (a窗口.m标识) {
		case e按钮0:
			w文字.f属性_s文本(L"123aaaaaaaa", {26});
			break;
		case e按钮1:
			w文字.f属性_s文本(L"aaaaaaaaaaa", {10});
			break;
		case e按钮2:
			v用户界面.f切换窗口(C程序::fg窗口(3));
			//v用户界面->f新建窗口(*C程序::m窗口2);
			//v用户界面->f设置活动窗口(*C程序::m窗口2);
			break;
		case e连击按钮:
			w文字.f属性_s文本内容(std::to_wstring(w连击按钮.m次数));
			break;
		}
		break;
	}
}
void W主窗口::f事件_窗口值变化(W窗口 &a, const int &a前, int &a后) {
	switch (a.m标识) {
	case e滚动条:
		w文字.f属性_s文本内容(std::to_wstring(a后));
		break;
	}
}