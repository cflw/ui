#include "用户界面_头.h"
#include "用户界面_基础.h"
#include "用户界面_窗口.h"
#include "用户界面_引擎.h"
namespace 用户界面 {
//==============================================================================
// 文本样式
//==============================================================================
const S文本样式 S文本样式::c默认样式;
//==============================================================================
// 主题
//==============================================================================
const S主题 S主题::c白(t颜色(1, 1, 1, 1), t颜色(1, 1, 1, 1));
S主题::S主题(const t颜色 &a前景色, const t颜色 &a背景色):
	m前景色(a前景色),
	m背景色(a背景色) {
}
t颜色 S主题::fg颜色(float a插值, float a亮度, float a透明度) const {
	t颜色 v = 数学::f插值<t颜色>(m背景色, m前景色, a插值);
	v = v.f颜色分量乘(a亮度);
	v.a *= a透明度;
	return v;
}
//==============================================================================
// 切换动画变量
//==============================================================================
void C切换动画::f重置(float a延时) {
	m目标 = c渐入结束;
	m实际 = c渐入开始 - a延时;
}
void C切换动画::f计算(bool a结束, float a间隔) {
	if (a结束) {	//结束
		if (m目标 < c渐出结束) {	//目标范围[1,∞)
			m目标 = c渐出结束;
		}
		m目标 += a间隔 * c切换速度;
	} else {	//开始
		m目标 = c渐入结束;
	}
	const float v计算秒 = C用户界面::fg实例().fg计算秒();
	m实际 = 数学::f倍数渐变<float>(m实际, m目标, 10 * v计算秒, v计算秒 * 2);
}
bool C切换动画::fi已消失() const {
	return m实际 >= c渐出结束;
}
bool C切换动画::fi出现中() const {
	return m实际 < c渐入结束;
}
bool C切换动画::fi消失中() const {
	return m实际 > c渐出开始;
}
float C切换动画::fg目标() const {
	return m目标;
}
float C切换动画::fg实际() const {
	return m实际;
}
float C切换动画::fg透明度() const {
	return 1 - abs(m实际);
}
void C总切换::f更新(W窗口 &a窗口) {
	m最小目标 = m最大目标 = a窗口.m切换.m目标;
	m最小实际 = m最大实际 = a窗口.m切换.m实际;
	const W窗口 *v父 = a窗口.m父窗口;
	while (v父) {
		const auto &v切换 = v父->m切换;
		m最小目标 = std::min(m最小目标, v切换.m目标);
		m最大目标 = std::max(m最大目标, v切换.m目标);
		m最小实际 = std::min(m最小实际, v切换.m实际);
		m最大实际 = std::max(m最大实际, v切换.m实际);
		v父 = v父->m父窗口;
	}
}
float C总切换::fg目标() const {
	return (m最小目标 + m最大目标) * 0.5f;
}
float C总切换::fg实际() const {
	return (m最小实际 + m最大实际) * 0.5f;
}
float C总切换::fg透明度() const {
	return 1 - std::max(std::abs(m最小实际), std::abs(m最大实际));
}
//==============================================================================
// 参数
//==============================================================================
bool S方向键参数::fi上() const {
	return y > 0;
}
bool S方向键参数::fi下() const {
	return y < 0;
}
bool S方向键参数::fi左() const {
	return x < 0;
}
bool S方向键参数::fi右() const {
	return x > 0;
}
bool S方向键参数::fi上下() const {
	return y != 0;
}
bool S方向键参数::fi左右() const {
	return x != 0;
}
S布局参数::S布局参数(const t向量2 &a坐标, const t向量2 &a尺寸):
	m坐标(a坐标), m尺寸(a尺寸) {
}
S布局参数::S布局参数(const t矩形 &a矩形):
	m坐标(a矩形.fg中心()), m尺寸(a矩形.fg尺寸()) {
}
//==============================================================================
// 切换动画计算
//==============================================================================
void C动画计算::f默认() {
	if (mf坐标 == nullptr) {
		mf坐标 = f坐标_从右到左;
	}
	if (mf尺寸 == nullptr) {
		mf尺寸 = f尺寸_无;
	}
}
//坐标
t向量2 C动画计算::f坐标_无(const W窗口 &a窗口) {
	const W窗口 *v窗口 = &a窗口;
	t向量2 v;
	while (v窗口) {
		v += v窗口->m坐标;
		v窗口 = v窗口->m父窗口;
	}
	return v;
}
t向量2 C动画计算::f坐标_从右到左(const W窗口 &a窗口) {
	t向量2 v = f坐标_无(a窗口);
	v.x += a窗口.fg总切换().fg实际() * -60;
	return v;
}
t向量2 C动画计算::f坐标_下拉(const W窗口 &a窗口) {
	t向量2 v = f坐标_无(a窗口);
	v.y += abs(a窗口.fg总切换().fg实际()) * 30;
	return v;
}
t向量2 C动画计算::f坐标_缩放(const W窗口 &a窗口) {
	const float v倍数 = 1 - abs(a窗口.fg总切换().fg实际());
	t向量2 v = a窗口.m坐标 * v倍数;
	v += f坐标_无(*a窗口.m父窗口);
	return v;
}
//范围
t向量2 C动画计算::f尺寸_无(const W窗口 &a窗口) {
	return a窗口.m尺寸;
}
t向量2 C动画计算::f尺寸_缩放(const W窗口 &a窗口) {
	const float v倍数 = 1 - abs(a窗口.fg总切换().fg实际());
	return a窗口.m尺寸 * v倍数;
}
//==============================================================================
// 渐变插值
//==============================================================================
S渐变插值::operator float() const {
	return m值;
}
float S渐变插值::f渐变(bool a) {
	const float v目标 = a ? 1.f : 0.f;
	m值 = 数学::f线性渐变<float>(m值, v目标, c速度 * C用户界面::fg实例().fg渲染秒());
	return m值;
}
float S渐变插值::f插值(float a小, float a大) const {
	return 数学::f插值<float>(a小, a大, m值);
}
//==============================================================================
// 平移计算
//==============================================================================
C平移计算::C平移计算(W窗口 &a窗口):
	m窗口(&a窗口), m来源(E按键来源::e无), m开始位置(), m当前位置(), m速度() {
}
bool C平移计算::fi来源(E按键来源 a来源) const {
	return m来源 == a来源;
}
void C平移计算::f重置(E按键来源 a来源, const t向量2 &a位置) {
	m来源 = a来源;
	m开始位置 = a位置;
	m当前位置 = a位置;
	m速度 = t向量2::c零;
	m时间点 = E时间点::e开始;
}
void C平移计算::f拖动计算(const t向量2 &a位置) {
	const float v过秒 = C用户界面::fg实例().fg计算秒();
	const t向量2 v速度 = a位置 - m当前位置;
	m平滑速度 = (v速度 + m平滑速度) * 0.5f;
	m速度 = v速度;
	m当前位置 = a位置;
	m时间点 = E时间点::e进行中;
}
void C平移计算::f滚轮计算(const t向量2 &a位置) {
	f拖动计算(a位置);
}
void C平移计算::f停止计算() {
	const float v过秒 = C用户界面::fg实例().fg计算秒();
	const float v减后速度 = m平滑速度.fg大小() + c停止加速度 * v过秒;
	if (v减后速度 < 1) {
		m平滑速度 = t向量2::c零;
	} else {
		m平滑速度.fs大小(v减后速度);
		m当前位置 += m平滑速度 * v过秒;
	}
	m时间点 = E时间点::e结束;
}
void C平移计算::f调用响应() {
	const auto f调用 = [this, &v目标速度 = (m时间点 == E时间点::e结束 ? m平滑速度 : m速度)]
	(void (W窗口::*af平移)(const S平移参数 &), const float(t向量2::*ap方向)) {
		const float v速度 = v目标速度.*ap方向;
		if (v速度 == 0) {
			return;
		}
		const S平移参数 v参数 = {m来源, m时间点, m开始位置.*ap方向, m当前位置.*ap方向, v速度};
		(m窗口->*af平移)(v参数);
	};
	f调用(&W窗口::f响应_水平平移, &t向量2::x);
	f调用(&W窗口::f响应_垂直平移, &t向量2::y);
}
}	//namespace 用户界面
//==============================================================================
namespace std {
size_t hash<用户界面::S文本样式>::operator()(const 用户界面::S文本样式 &a) const {
	const size_t h1 = std::hash<float>()(a.m字号);
	const size_t h2 = std::hash<int>()(a.m水平对齐);
	const size_t h3 = (a.m粗体 ? 0xaa000000 : 0) + (a.m斜体 ? 0xaa0000 : 0) + (a.m下划线 ? 0xaa00 : 0) + (a.m删除线 ? 0xaa : 0);
	return h1 ^ (h2 << 1) ^ h3;
}
}	//namespace std