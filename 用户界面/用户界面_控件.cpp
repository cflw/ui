#include "用户界面_引擎.h"
#include "用户界面_控件.h"
#include "用户界面_布局.h"
import 用户界面.控件常量;
namespace 用户界面 {
//==============================================================================
// 控件文本
//==============================================================================
const std::wstring C控件文本::c默认文本 = c调试 ? L"(文本)" : L"";
C控件文本::C控件文本(const std::wstring &a文本):
	m文本(a文本) {
}
C控件文本::C控件文本(const std::wstring &a文本, const S文本样式 &a样式):
	m文本(a文本), m样式(a样式) {
}
void C控件文本::f属性_s空文本() {
	m文本.clear();
}
void C控件文本::f属性_s文本(const std::wstring_view &a文本, const S文本样式 &a样式) {
	assert(a样式.m字号 > 1);
	f属性_s文本内容(a文本);
	f属性_s文本样式(a样式);
}
void C控件文本::f属性_s文本内容(const std::wstring_view &a文本) {
	m文本 = a文本;
}
void C控件文本::f属性_s文本样式(const S文本样式 &a样式) {
	m样式 = a样式;
}
bool C控件文本::f属性_i有文本() const {
	return !m文本.empty();
}
//==============================================================================
// 窗口框架
//==============================================================================
W窗口框架::W窗口框架(int a标识, int a值):
	W窗口(a标识, a值) {
	f动作_启用();
	f标志_s纯鼠标();
}
void W窗口框架::f响应_鼠标按下(const S按键参数 &a) {
	m标志[e鼠标按下] = true;
}
void W窗口框架::f响应_鼠标松开(const S按键参数 &a) {
	this->f事件_按键(*this, a);
	m标志[e鼠标按下] = false;
}
bool W窗口框架::f响应_i范围内(const t向量2 &) {
	return m标志[e容器];
}
//==============================================================================
// 空白按钮
//==============================================================================
W空白按钮::W空白按钮(int a标识, int a值):
	W窗口(a标识, a值) {
	m标志[e禁用] = false;
}
void W空白按钮::f响应_鼠标按下(const S按键参数 &a) {
	if (m鼠标按键 != E按键::e无) {
		return;
	}
	if (m标志[e鼠标范围]) {
		m鼠标按键 = a.m按键;
		m标志[e鼠标按下] = true;
	}
}
void W空白按钮::f响应_鼠标松开(const S按键参数 &a) {
	if (m鼠标按键 != a.m按键) {
		return;
	}
	if (m标志[e鼠标按下] && m标志[e鼠标范围]) {
		f动作_按键(a);
	}
	m标志[e鼠标按下] = false;
	m鼠标按键 = E按键::e无;
}
void W空白按钮::f动作_按键(const S按键参数 &a) {
	m父窗口->f事件_按键(*this, a);
}
void W空白按钮::f动作_按键(E按键 a按键) {
	f动作_按键(S按键参数{E按键来源::e无, a按键, E时间点::e一次, t向量2::c零});
}
//==============================================================================
// 标签
//==============================================================================
const std::wstring W标签::c默认文本 = c调试 ? L"(标签)" : L"";
W标签::W标签(int n, int v): W窗口(n, v), C控件文本(c默认文本) {
}
void W标签::f响应_显示(const S显示参数 &a) const {
	a.m图形.f绘制文本(m文本, fg动画矩形(), a.m主题.fg颜色(1, 1, fg总切换().fg透明度() * m透明度), m样式);
}
void W标签::f属性_s透明度(float a) {
	m透明度 = a;
}
//==============================================================================
// 按钮
//==============================================================================
const std::wstring W按钮::c默认文本 = c调试 ? L"(按钮)" : L"";
W按钮::W按钮(int n, int v): W空白按钮(n, v), C控件文本(c默认文本) {
	m标志[e禁用] = false;
}
void W按钮::f响应_显示(const S显示参数 &a) const {
	if (m尺寸.x == 0 || m尺寸.y == 0) {
		return;
	}
	const float v按下 = m标志[e鼠标按下] ? 0.2f : 0;
	const float v切换透明 = fg总切换().fg透明度();
	const t矩形 &v动画矩形 = fg动画矩形();
	//背景
	const t颜色 v背景色 = a.m主题.fg颜色(0, (m标志[e鼠标按下] ? 0.3f : 0.5f), m焦点渐变.f插值(0.2f, 0.5f) * v切换透明);
	if (f标志_i显示背景()) {
		a.m图形.f填充矩形(v动画矩形, v背景色);
	}
	//前景
	const t颜色 v前景色 = a.m主题.fg颜色(1, 1, m焦点渐变.f插值(0.8f, 1) * v切换透明);
	if (f标志_i显示边框()) {
		a.m图形.f绘制矩形(v动画矩形, v前景色);
	}
	//文本
	if (f属性_i有文本()) {
		a.m图形.f绘制文本(m文本, v动画矩形, v前景色, m样式);
	}
}
//==============================================================================
// 文本框
//==============================================================================
W文本框::W文本框(int n, int v) : W窗口(n, v) {
	m标志[e禁用] = false;
}
float W文本框::f按行计算高度(int a行数) {
	return a行数 * c行高度 + c边距 * 2;
}
void W文本框::f响应_显示(const S显示参数 &a) const {
	const float v切换透明 = fg总切换().fg透明度();
	const float v透明度 = m焦点渐变.f插值(0.5f, 1) * v切换透明;
	const t矩形 &v动画矩形 = fg动画矩形();
	const t矩形 &v文本矩形 = fg动画矩形(t向量2::c零, t向量2::fc相同(-c边距));
	//边框
	if (m标志[e显示边框]) {
		const t颜色 v边框颜色 = a.m主题.fg颜色(1, m焦点渐变.f插值(0.5f, 1), m焦点渐变.f插值(0.5f, 0.8f) * v切换透明);
		a.m图形.f绘制矩形(v动画矩形, v边框颜色);
	}
	//文本
	if (!m文本.empty()) {
		const t颜色 v文本颜色 = a.m主题.fg颜色(1, 1, m焦点渐变.f插值(0.5f, 1) * v切换透明);
		a.m图形.f绘制文本(m文本, v文本矩形, v文本颜色, {c字号, e居左});
	}
	const t颜色 v字数颜色 = a.m主题.fg颜色(1, 0.5f, m焦点渐变.f插值(0.0f, 0.8f) * v切换透明);
	a.m图形.f绘制文本(std::to_wstring(m限制字数 - m文本.size()), v文本矩形, v字数颜色, {c字号, e居右});
}
void W文本框::f响应_字符(const std::vector<wchar_t> &aa字符) {
	for (const auto &v字符 : aa字符) {
		switch (v字符) {
		case '\b':
			if (!m文本.empty()) {
				m文本.pop_back();
			}
			break;
		case '\r':
			if (!m标志[e多行]) {
				break;
			}
		default:
			if (m文本.size() < m限制字数) {
				m文本.push_back(v字符);
			}
			break;
		}
	}
}
void W文本框::f属性_s布局(const S布局参数 &a参数) {
	m尺寸 = a参数.m尺寸;
	if (m尺寸.y < c最小高度) {
		m尺寸.y = c最小高度;
	}
	const float v行数 = floor(m尺寸.y / c行高度);
	if (v行数 > 1) {
		f属性_s多行(true);
	}
	m坐标 = a参数.m坐标;
}
void W文本框::f属性_s多行(bool a) {
	m标志[e多行] = a;
}
void W文本框::f属性_s限制字数(size_t a) {
	m限制字数 = a;
}
//==============================================================================
// 虚拟键盘
//==============================================================================
W虚拟键盘::W虚拟键盘() {
	//数字

}
//==============================================================================
// 连击按钮
//==============================================================================
W连击按钮::W连击按钮(int n, int v) : W按钮(n, v) {
}
void W连击按钮::f属性_s连击间隔(float a首次, float a每次) {
	m首次 = a首次;
	if (a每次 <= 0) {
		m每次 = a首次;
	} else {
		m每次 = a每次;
	}
}
void W连击按钮::f响应_计算() {
	if (f状态_i按下()) {
		C用户界面 &v用户界面 = fg引擎();
		const float v间隔 = v用户界面.fg计算秒();
		const float &v时间 = (m次数 == 0) ? m首次 : m每次;
		m计时 += v间隔;
		if (m计时 >= v时间) {
			f确定回调({E按键来源::e无, E按键::e确定});
			m计时 -= v时间;
			++m次数;
		}
	}
}
void W连击按钮::f响应_按键(const S按键参数 &a) {
	if (a.m按键 == E按键::e确定) {
		f动作_连击重置();
		f确定回调(a);
	}
}
void W连击按钮::f响应_鼠标按下(const S按键参数 &a) {
	if (m标志[e鼠标范围]) {
		f响应_按键(a);
		m标志[e鼠标按下] = true;
	}
}
void W连击按钮::f响应_鼠标松开(const S按键参数 &) {
	m标志[e鼠标按下] = false;
}
void W连击按钮::f动作_连击重置() {
	m计时 = 0;
	m次数 = 0;
}
void W连击按钮::f确定回调(const S按键参数 &a) {
	assert(a.m按键 == E按键::e确定);
	m父窗口->f事件_按键(*this, a);
}
//==============================================================================
// 滑动块
//==============================================================================
W滑动块::W滑动块(int n, int v): W按钮(n, v) {
	f标志_s纯鼠标();
}
void W滑动块::f响应_初始化() {
	m被动坐标 = m坐标;
}
void W滑动块::f响应_计算() {
	if (!m标志[e鼠标按下]) {
		const float v计算秒 = fg引擎().fg计算秒();
		m坐标.fs倍数渐变(m被动坐标, 10 * v计算秒);
	}
}
bool W滑动块::f响应_i范围内(const t向量2 &a) {
	if (m标志[e鼠标按下]) {
		if (m鼠标坐标 != a) {
			const t向量2 v移动 = a - m鼠标坐标;
			m坐标 += v移动;
			m父窗口->f事件_窗口移动(*this, v移动);
			m被动坐标 = m坐标;
		}
	}
	return W窗口::f响应_i范围内(a);
}
void W滑动块::f响应_鼠标按下(const S按键参数 &a) {
	if (a.m按键 == E按键::e确定 && m标志[e鼠标范围]) {
		m鼠标坐标 = a.m坐标;
		m标志[e鼠标按下] = true;
	}
}
void W滑动块::f响应_鼠标松开(const S按键参数 &a) {
	if (m标志[e鼠标按下]) {
		m父窗口->f事件_按键(*this, a);
		m标志[e鼠标按下] = false;
	}
}
void W滑动块::f属性_s布局(const S布局参数 &a参数) {
	m坐标 = a参数.m坐标;
	m被动坐标 = a参数.m坐标;
	m尺寸 = a参数.m尺寸;
}
//==============================================================================
// 滑动块2
//==============================================================================
W滑动块2::W滑动块2(int n, int v) : W按钮(n, v) {
	f标志_s纯鼠标();
	m标志[e可获得平移焦点] = true;
}
void W滑动块2::f响应_初始化() {
	m被动坐标 = m坐标;
}
void W滑动块2::f响应_计算() {
	if (!m标志[e鼠标按下]) {
		const float v计算秒 = fg引擎().fg计算秒();
		m坐标.fs倍数渐变(m被动坐标, 10 * v计算秒);
	}
}
bool W滑动块2::f响应_i范围内(const t向量2 &a) {
	return W窗口::f响应_i范围内(a);
}
void W滑动块2::f响应_垂直平移(const S平移参数 &a) {
	f响应平移(a, &t向量2::y);
}
void W滑动块2::f响应_水平平移(const S平移参数 &a) {
	f响应平移(a, &t向量2::x);
}
void W滑动块2::f响应平移(const S平移参数 &a, float (t向量2::*ap)) {
	m被动坐标.*ap = m坐标.*ap += a.m速度;
}
void W滑动块2::f属性_s布局(const S布局参数 &a参数) {
	m坐标 = a参数.m坐标;
	m被动坐标 = a参数.m坐标;
	m尺寸 = a参数.m尺寸;
}
//==============================================================================
// 复选框
//==============================================================================
W复选框::W复选框(int id, int v):
	W按钮(id, v) {
}
void W复选框::f响应_初始化() {
	f属性_s文本(f属性_g字符(), {m尺寸.y, e居中});
}
void W复选框::f响应_按键(const S按键参数 &a) {
	switch (a.m按键) {
	case E按键::e确定:
		f属性_反选();
		m父窗口->f事件_按键(*this, a);
	default:
		W按钮::f响应_按键(a);
		break;
	}
}
void W复选框::f响应_鼠标按下(const S按键参数 &a) {
	switch (a.m按键) {
	case E按键::e确定:
		if (m标志[e鼠标范围]) {
			m标志[e鼠标按下] = true;
		}
		break;
	default:
		W按钮::f响应_鼠标按下(a);
		break;
	}
}
void W复选框::f响应_鼠标松开(const S按键参数 &a) {
	switch (a.m按键) {
	case E按键::e确定:
		if (m标志[e鼠标范围] && m标志[e鼠标按下]) {
			f属性_反选();
			m父窗口->f事件_按键(*this, a);
		}
		m标志[e鼠标按下] = false;
		break;
	default:
		W按钮::f响应_鼠标松开(a);
		break;
	}
}
void W复选框::f属性_反选() {
	const int v前 = m标志[e选中];
	int v后 = !v前;
	m父窗口->f事件_窗口值变化(*this, v前, v后);
	m标志[e选中] = v后;
	f属性_s文本内容(f属性_g字符());
}
bool W复选框::f属性_i选中() const {
	return m标志[e选中];
}
const std::wstring &W复选框::f属性_g字符() const {
	if (f属性_i选中()) {
		return c正确;
	} else {
		return c错误;
	}
}
}	//namespace 用户界面